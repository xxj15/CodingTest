## 📚 자료구조 (스택/큐/힙/해시/정렬)

- 자료구조 : 데이터를 저장하고 관리하는 방식을 의미.
  데이터를 체계적으로 저장하여 메모리를 효율적으로 사용하고, 빠르고 안정적으로 데이터를 처리할 수 있도록 도와주기 때문에 중요함.

### 📍선형 자료구조 vs 비선형 자료구조

#### 선형 자료구조

- 데이터가 연속적으로 나열된 형태를 가지며, 각 데이터 요소가 순차적으로 연결된 구조를 의미.
- 데이터 요소들 간의 관계가 1:1

⚡ 예시

- 배열(Array)
- 동적 배열 (Dynamic Array)
- 연결 리스트 (Linked List)
- 스택 (Stack) / 큐 (Queue)
- 해시 테이블 (Hash Table)

#### 비선형 자료구조

- 데이터 요소들이 계층적 또는 네트워크 형태로 연결된 구조.
- 데이터 요소들 간의 관계가 1:다 혹은 다:다

⚡ 예시

- 트리 (Tree)
- 그래프 (Graph)

---

### 📍 스택 (Stack)

#### ⚡ 스택 정의

스택 : 한쪽 끝에서만 데이터를 넣고 뺄 수 있는 제한적으로 접근할 수 있는 **후입선출(Last-In-First-Out) 형태**의 선형 자료구조

#### ⚡ 스택을 활용한 주요 연산

| 연산 이름          | 설명                                            |
| ------------------ | ----------------------------------------------- |
| `push(x)`          | 요소 `x`를 스택의 top에 추가                    |
| `pop()`            | 스택의 top 요소를 제거하고 반환                 |
| `peek()` / `top()` | 스택의 top 요소를 제거하지 않고 반환            |
| `isEmpty()`        | 스택이 비어 있는지 확인                         |
| `isFull()`\*       | 스택이 가득 찼는지 확인 (배열 기반 스택일 경우) |

> `isFull()`은 고정 크기의 배열로 구현할 때만 사용한다.

#### ⚡ 스택 활용 예시

- 함수 호출(재귀) 관리
- 웹 브라우저의 뒤로 가기 기능
- 수식 계산 (후위 표기법, 중위 → 후위 변환)
- 괄호 짝 검사
- DFS(깊이 우선 탐색) 구현

---

### 📍 큐 (Queue)

#### ⚡ 큐 정의

큐 : 한쪽 끝에서 데이터를 넣고, 다른 쪽 끝에서 데이터를 빼는 **선입선출(First-In-First-Out, FIFO) 형태**의 선형 자료구조

#### ⚡ 큐를 활용한 주요 연산

| 연산 이름            | 설명                                        |
| -------------------- | ------------------------------------------- |
| `enqueue(x)`         | 요소 `x`를 큐의 rear(뒤쪽)에 추가           |
| `dequeue()`          | 큐의 front(앞쪽) 요소를 제거하고 반환       |
| `peek()` / `front()` | 큐의 front 요소를 제거하지 않고 반환        |
| `isEmpty()`          | 큐가 비어 있는지 확인                       |
| `isFull()`\*         | 큐가 가득 찼는지 확인 (배열 기반 큐일 경우) |

> `isFull()`은 고정 크기의 배열로 구현할 때만 사용한다.

#### ⚡ 큐 활용 예시

- 은행 대기열 시스템
- CPU 작업 스케줄링
- 그래프의 BFS(너비 우선 탐색)
- 프린터 작업 처리
- 네트워크 패킷 처리

### 💡 원형 큐

원형 큐 : 큐의 공간을 효율적으로 사용하기 위해 **배열의 끝과 시작이 연결된 것처럼 동작**하는 큐.

> 배열의 마지막 인덱스 다음은 다시 0번 인덱스로 이어짐.

#### ⚡ 원형 큐를 활용한 주요 연산

| 연산 이름            | 설명                                              |
| -------------------- | ------------------------------------------------- |
| `enqueue(x)`         | 요소 `x`를 rear 위치에 추가하고 rear를 한 칸 이동 |
| `dequeue()`          | front 위치의 요소를 제거하고 front를 한 칸 이동   |
| `peek()` / `front()` | front 위치의 요소를 반환                          |
| `isEmpty()`          | front == rear일 때 큐가 비어 있음                 |
| `isFull()`           | `(rear + 1) % size == front`일 때 큐가 가득 참    |

#### ⚡ 원형 큐 활용 예시

- 고정된 공간에서 반복적으로 데이터를 처리할 때
- 네트워크 버퍼
- 시계 방향으로 순환하는 작업 관리
- 실시간 데이터 스트리밍 처리

### 💡 덱 (Deque)

덱(Deque) : **양쪽 끝(front와 rear) 모두에서 삽입과 삭제가 가능한 큐**

> 스택과 큐의 장점을 모두 가진 자료구조

#### ⚡ 덱을 활용한 주요 연산

| 연산 이름                 | 설명                                        |
| ------------------------- | ------------------------------------------- |
| `addFront(x)`             | 요소 `x`를 덱의 front에 추가                |
| `addRear(x)`              | 요소 `x`를 덱의 rear에 추가                 |
| `removeFront()`           | 덱의 front 요소를 제거하고 반환             |
| `removeRear()`            | 덱의 rear 요소를 제거하고 반환              |
| `peekFront()` / `front()` | 덱의 front 요소를 반환                      |
| `peekRear()` / `rear()`   | 덱의 rear 요소를 반환                       |
| `isEmpty()`               | 덱이 비어 있는지 확인                       |
| `isFull()`\*              | (배열 기반 덱일 경우) 덱이 가득 찼는지 확인 |

#### ⚡ 덱 활용 예시

- 양방향 탐색 (예: 슬라이딩 윈도우 최댓값 문제)
- 스케줄러 또는 작업 우선순위 관리
- 텍스트 편집기의 undo/redo 기능
- 스택과 큐 역할을 동시에 요구하는 문제

---

### 📍 힙 (Heap)

힙(Heap) : **완전 이진 트리 형태**를 가지며, 특정한 규칙을 만족하는 트리 기반의 자료구조이다.

- **최대 힙 (Max Heap)** : 부모 노드 ≥ 자식 노드
- **최소 힙 (Min Heap)** : 부모 노드 ≤ 자식 노드  
  항상 루트 노드에 최댓값 또는 최솟값이 위치한다.

#### ⚡ 힙을 활용한 주요 연산

| 연산 이름            | 설명                                                      |
| -------------------- | --------------------------------------------------------- |
| `insert(x)`          | 요소 `x`를 힙에 추가하고, 규칙에 맞게 재정렬 (heapify-up) |
| `remove()` / `pop()` | 루트 노드를 제거하고, 규칙에 맞게 재정렬 (heapify-down)   |
| `peek()` / `top()`   | 루트 노드(최댓값 또는 최솟값)를 반환                      |
| `isEmpty()`          | 힙이 비어 있는지 확인                                     |

#### ⚡ 힙 활용 예시

- 우선순위 큐(Priority Queue) 구현
- 힙 정렬(Heap Sort)
- Dijkstra 알고리즘 (최단 경로)
- 실시간 순위 관리 (ex. Top-K 문제)

#### ⚡ 힙 추가 설명

- **시간 복잡도**:
  - 삽입: O(log n)
  - 삭제: O(log n)
  - 조회(top): O(1)
- **자료구조 구현**: 주로 배열로 구현되며, 인덱스를 이용해 부모/자식 노드 위치를 계산함

---

### 📍 해시 (Hash)

#### ⚡ 해시 정의

해시(Hash) : **키(key)**를 해시 함수(Hash Function)를 통해 **고유한 인덱스(해시값)**로 변환해 데이터를 저장하거나 검색하는 자료구조  
일반적으로 해시 테이블(Hash Table) 또는 해시 맵(Hash Map) 형태로 사용됨

#### ⚡ 해시를 활용한 주요 연산

| 연산 이름          | 설명                           |
| ------------------ | ------------------------------ |
| `put(key, value)`  | 키-값 쌍을 해시 테이블에 저장  |
| `get(key)`         | 키에 해당하는 값을 반환        |
| `remove(key)`      | 해당 키의 데이터를 삭제        |
| `containsKey(key)` | 해당 키가 존재하는지 확인      |
| `isEmpty()`        | 해시 테이블이 비어 있는지 확인 |

#### ⚡ 해시 활용 예시

- 사전(Dictionary) 구현
- 중복 탐지 / 빠른 검색
- 캐시(Cache) 구현
- 데이터베이스 인덱싱
- 집합(Set) 구현

#### ⚡ 해시 추가 설명

- **시간 복잡도** (평균):
  - 삽입, 삭제, 조회: O(1)
- **해시 충돌(Collision)**:
  - 서로 다른 키가 같은 해시값을 갖는 경우
  - 해결 방법: 체이닝(Chaining), 개방 주소법(Open Addressing) 등
- **해시 함수**:
  - 좋은 해시 함수는 키를 고르게 분포시켜야 함
