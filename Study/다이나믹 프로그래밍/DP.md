# 다이나믹 프로그래밍

📌 다이나믹 프로그래밍의 의의 : 중복되는 연산을 줄이자

- 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시키는 방법

### 예시) 피보나치 함수

📍 **재귀 함수로 구현**

```
def fibo(x):
  if x == 1 or x == 2:
    return 1
  return fibo(x-1) + fibo(x-2)

print(fibo(4))
```

=> 하지만 이렇게 피보나치 수열의 소스코드를 작성하면, **f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다**는 문제 존재!

### 💡 **해결책 : 다이나믹 프로그래밍**

📍 **재귀적으로 구현**

- **Memoization(메모이제이션)** 기법 사용 : 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져옴.
- 값을 저장하는 방법이므로 **캐싱(Caching)**이라고도 함.

```
# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
d = [0]*100

def fibo(x):
  # 종료 조건
  if x == 1 or x == 2 :
    return 1

  if d[x]!= 0 :
    return d[x]

  d[x] = fibo(x-1) + fibo(x-2)

  return d[x]

print(fibo(99))
```

### ⚡️ 다이나믹 프로그래밍을 사용할 수 있는 조건

1. 큰 문제를 작은 문제로 나눌 수 있다
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

- 분할 정복 (Divide and Conquer) 과의 차이점 : DP는 문제들이 서로 영향을 미치고 있다는 점

### Top-Down vs Bottom-Up

- **Top-Down 방식** : 재귀 함수를 이용하여 DP 소스코드를 작성. 큰 문제를 해결하기 위해 작은 문제를 호출하는 것

  - 메모이제이션 방식. 하향식
  - 사용되는 결과 저장용 리스트를 **'DP 테이블'** 이라고 불,ㅁ.

- **Bottom-Up 방식** : 단순히 반복문을 이용하여 소스코드를 작성하는 경우. 작은 문제부터 차근차근 답을 도출
  - 상향식

🌱 가능하다면 재귀 함수를 이용하는 **탑다운 방식보다는 보텀업 방식으로 구현**하는 것을 권장. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문

🌱 `setrecursionlimit()`함수

- sys 라이브러리에 포함됨
- recursion depth 관련 오류 발생시에 사용
